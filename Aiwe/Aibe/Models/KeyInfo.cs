using System.Collections.Generic;
using System.Linq;
using Extension.String;

namespace Aibe.Models {
  public partial class KeyInfo {
    public string TableName { get; private set; }
    public string Key { get; private set; }
    public string PureKeyName { get; private set; }
    public string AddKeyName { get; private set; }
    public string DataType { get; set; }
    public bool IsNullified { get; set; } = false;
    public bool IsAutoGenerated { get; set; } = false;
    public bool IsTimeStamp { get; set; } = false;
    public bool IsTimeStampFixed { get; set; } = true;
    public int TimeStampShift { get; set; }
    public KeyInfo(string tableName, string usedKey) {
      int addIndex = usedKey.IndexOf(DH.BaseAppendixName);
      TableName = tableName;
      Key = usedKey;
      PureKeyName = addIndex >= usedKey.Length || addIndex == -1 ? usedKey : usedKey.Substring(0, addIndex);
      AddKeyName = PureKeyName == usedKey ? string.Empty : usedKey.Substring(PureKeyName.Length);
      if (Key == PureKeyName)
        DataType = DH.StringDataType;
      else if (DH.NumberTypeFilterColumns.Contains(AddKeyName)) { //time is excluded if date does not contain
        int startIndex = DH.BaseFilterAppendixName.Length;
        int length = AddKeyName.Length - DH.BaseFilterAppendixName.Length - (AddKeyName.EndsWith("From") ? 4 : 2);
        DataType = AddKeyName.Substring(startIndex, length);
      } else if (DH.FilterDateAppendixNames.Contains(AddKeyName))
        DataType = DH.DateTimeDataType;
      else if (DH.BooleanTypeFilterColumns.Contains(AddKeyName))
        DataType = DH.BooleanDataType;
      else if (DH.CharTypeFilterColumns.Contains(AddKeyName))
        DataType = DH.CharDataType;
      //Add other DataType here
      else
        DataType = DH.UnknownDataType;
    }

    public void UpdateTimeStampAndAutoGenerated(MetaInfo meta, string columnName, string actionType) {
      IsTimeStamp = meta != null &&
        DataType.EqualsIgnoreCase(DH.DateTimeDataType) &&
        !string.IsNullOrWhiteSpace(actionType) &&
        meta.IsTimeStampAppliedFor(columnName, actionType);
      if (IsTimeStamp) {
        IsTimeStampFixed = meta.IsTimeStampFixedFor(columnName, actionType);
        TimeStampShift = meta.GetTimeStampShiftFor(columnName, actionType);
      }

      IsAutoGenerated = meta != null &&
        DH.NumberDataTypes.Any(x => x.EqualsIgnoreCase(DataType)) &&
        !string.IsNullOrWhiteSpace(actionType) &&
        meta.IsAutoGeneratedAppliedFor(columnName, actionType);
    }

    //public static object ExtractValueAsObjectForWebApi(string dataType, string dataValue, bool isTimeStamp, bool isAutoGenerated) {
    //  return ExtractValueAsObjectForWebApi(dataType, dataValue, DateTime.Now, isTimeStamp, isAutoGenerated);
    //}

    public static List<KeyValuePair<string, string>> GetTableColumnPairs(MetaInfo meta, string columnName) {
      if (!meta.IsAutoGenerated(columnName)) //Not need to further check
        return null;
      List<KeyValuePair<string, string>> tableColumnNamePairs = null;
      AutoGeneratedColumnInfo agcInfo = meta.AutoGeneratedColumns //check if there is such info
        .FirstOrDefault(x => //first whose column name is correct is alread checked in the is auto-generated
          x.TableColumnPairs != null && x.TableColumnPairs.Any()); //and has extra action infos
      if (agcInfo != null)
        tableColumnNamePairs = agcInfo.TableColumnPairs.ToList();
      return tableColumnNamePairs;
    }

    public string CreateQuerySubstring(int parNo) {
      switch (DataType) {
        case DH.StringDataType:
        case DH.CharDataType:
          return string.Concat("[", PureKeyName, "] LIKE @par", parNo);
        case DH.Int16DataType: //Int and date time is shared here, something else could also be shared!
        case DH.Int32DataType:
        case DH.Int64DataType:
        case DH.UInt16DataType:
        case DH.UInt32DataType:
        case DH.UInt64DataType:
        case DH.ByteDataType:
        case DH.SByteDataType:
        case DH.DecimalDataType:
        case DH.DoubleDataType:
        case DH.SingleDataType:
        case DH.DateTimeDataType:
          return string.Concat("[", PureKeyName, "] ",
                AddKeyName.StartsWith(DH.BaseFilterAppendixName) && 
                AddKeyName.EndsWith(DH.FromName) ?
                ">" : "<", "= @par", parNo);
        case DH.BooleanDataType:        
          return string.Concat("[", PureKeyName, "] = @par", parNo);
        default:
          return null;
      }
    }

    public object CreateQueryValueAsObject(object value) {
      return DataType == DH.StringDataType || DataType == DH.CharDataType ? string.Concat("%", value, "%") :
        DataType == DH.BooleanDataType && value != null ? (value.ToString().EqualsIgnoreCase("true") ? 1 : 0) :
        value;
    }
  }
}