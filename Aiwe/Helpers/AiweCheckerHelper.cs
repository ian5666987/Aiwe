using System.Collections.Generic;
using System.Linq;
using System.Data;
using Aibe.Models;
using System;
using Extension.String;
using Aibe.Models.Core;
using System.Text.RegularExpressions;
using System.Text;
using System.Reflection;

namespace Aiwe.Helpers {
  public class AiweCheckerHelper {
    public static Dictionary<string, string> CheckModelValidity(
      string tableModelClassPrefix,
      string tableName,
      List<DataColumn> columns,
      Dictionary<string, string> collections,
      List<string> modelKeys,
      MetaInfo meta,
      List<string> checkExclusions,
      bool userIsDeveloper,
      DateTime refDtNow,
      string actionType,
      bool filterStyle = false) {
      //List<string> modelStateKeys = ModelState.Keys.ToList();
      Dictionary<string, string> errorDict = new Dictionary<string, string>();

      foreach (var key in modelKeys) {
        if (checkExclusions.Contains(key))
          continue; //no need to check if explicitly excluded

        bool isExplicitlyRequired = false;
        if (!filterStyle) { //Only on creation and edit
          //List<string> required = meta.RequiredColumns?.Split(';')?.ToList();
          isExplicitlyRequired = meta.RequiredColumns != null &&
            meta.RequiredColumns.Any(x => !string.IsNullOrWhiteSpace(x) && x.EqualsIgnoreCase(key));
        }

        //Now, get the value
        string val = collections[key];
        KeyInfo keyInfo = new KeyInfo(tableName, key);
        DataColumn column = columns.Where(x => x.ColumnName.EqualsIgnoreCase(keyInfo.PureKeyName)).FirstOrDefault();

        //If not filter style, then update the data type from the column given
        //filter style would already have correct data type
        if (!filterStyle)
          keyInfo.DataType = column.DataType.ToString().Substring(Aibe.DH.SharedPrefixDataType.Length);

        //If column names is not found, assumes it is an unknown injection
        if (column == null) {
          errorDict.Add("UnknownColumn", string.Concat(
            "The column name [", keyInfo.PureKeyName.ToCamelBrokenString(), "] is unknown"));
          //ModelState.Add("UnknownColumn", new ModelState());
          //ModelState.AddModelError("UnknownColumn", string.Concat(
          //  "The column name [", keyInfo.PureKeyName.ToCamelBrokenString(), "] is unknown"));
          continue;
        }

        //If things are not required, and not excepted and is null, no need for further check
        if (string.IsNullOrWhiteSpace(val)) {
          //if (isRequired || !column.AllowDBNull) //column.AllowDBNull, again, does NOT do what it ought to!
          if (!filterStyle) { //only non-filtered style has concept of "required"
            bool isNullable = columnIsNullableByClass(tableModelClassPrefix, meta.TableName, column.ColumnName);
            bool isImplicitlyRequired = columnIsRequiredByAttribute(tableModelClassPrefix, meta.TableName, column.ColumnName);
            if (isExplicitlyRequired || isImplicitlyRequired || !isNullable) //if things are required but null, there must be something wrong, required cannot be null
              errorDict.Add(key, string.Concat(
                "field [", keyInfo.PureKeyName.ToCamelBrokenString(), "] is required"));
            //ModelState.AddModelError(key, string.Concat(
            //  "field [", keyInfo.PureKeyName.ToCamelBrokenString(), "] is required"));
          }
          continue; //if things are not required or is filterStyle, immediately continue
        }

        //These must be checked AFTER the check for required/not-required, because if they are required, they cannot be skipped
        //Check if the items are implicitly excluded, filter or not, these keys don't matter to be further checked
        if (key.EndsWith(Aibe.DH.CreateEditTimeAppendixName) ||
            Aibe.DH.FilterTimeAppendixNames.Any(x => key.EndsWith(x)) ||
            Aibe.DH.FilterDateAppendixNames.Any(x => key.EndsWith(x)) ||
            key.EndsWith(Aibe.DH.CreateEditPictureLinkAppendixName)) //picture name is also unchecked from here onwards
          continue; //some null/non-null items like datetime need not to be further checked

        //From this point onwards, the item is not null or empty and is ont excluded explicitly or implicitly (that is, not datetime)
        //At this point, filter style need not further check
        if (filterStyle)
          continue; //TODO this was previously put as return. Check if it is error or if it is intended

        keyInfo.UpdateTimeStampAndAutoGenerated(meta, keyInfo.PureKeyName, actionType);
        //From this point onwards, data is already to be checked
        object value = keyInfo.ExtractValueAsObject(collections, refDtNow, filterStyle);
        if (value == null) //there must be something wrong with the format, otherwise the extracting cannot be null
          errorDict.Add(keyInfo.Key, string.Concat(
            "The input for field [", keyInfo.PureKeyName.ToCamelBrokenString(),
            "] is in a non-acceptable data format. The data type is [",
            keyInfo.DataType, "] but the value given is [", collections[keyInfo.Key],
            "]. Please correct your input data format"));
        //ModelState.AddModelError(keyInfo.Key, string.Concat(
        //    "The input for field [", keyInfo.PureKeyName.ToCamelBrokenString(),
        //    "] is in a non-acceptable data format. The data type is [",
        //    keyInfo.DataType, "] but the value given is [", collections[keyInfo.Key],
        //    "]. Please correct your input data format"));

        //Now, check if string length is violated against the length specified
        if (keyInfo.DataType.EqualsIgnoreCase(Aibe.DH.StringDataType) || keyInfo.DataType.EqualsIgnoreCase(Aibe.DH.CharDataType)) {
          //Painfully gets length by reflection, column.MaxLength does NOT show desired string length's limit!!
          int length = getStringLengthFor(tableModelClassPrefix, meta.TableName, keyInfo.PureKeyName);
          string strVal = value.ToString();
          string camelBrokenPureKeyName = keyInfo.PureKeyName.ToCamelBrokenString();
          if (strVal.Length > length) {
            errorDict.Add(keyInfo.Key, string.Concat(
              "The input string [", value,
              "] for [", camelBrokenPureKeyName,
              "] is too long. The maximum length for [", camelBrokenPureKeyName,
              "] is ", length, " character(s)"
              ));
            //ModelState.AddModelError(keyInfo.Key, string.Concat(
            //  "The input string [", value,
            //  "] for [", camelBrokenPureKeyName,
            //  "] is too long. The maximum length for [", camelBrokenPureKeyName,
            //  "] is ", length, " character(s)"
            //  ));
          }

          RegexCheckedColumnInfo regexInfo = meta.GetRegexCheckedColumn(keyInfo.PureKeyName);
          if (regexInfo != null) { //regex checked items
            ListColumnInfo listColumn = meta.GetListColumnInfo(keyInfo.PureKeyName); //to determine if items are in listColumn or not
            string valueString = value.ToString();
            string[] valueParts = listColumn == null ? new string[] { valueString } : valueString.Split(';');
            if (valueParts != null)
              for (int i = 0; i < valueParts.Length; ++i) {
                Regex regex = new Regex(regexInfo.Content);
                Match match = regex.Match(valueParts[i].ToString());
                if (!match.Success) {
                  StringBuilder regexError = new StringBuilder(string.Concat(
                    "The input string [", valueParts[i],
                    "] for [", camelBrokenPureKeyName, "] ",
                    "does not match with the required pattern"));

                  //AiweUserHelper.UserIsDeveloper(User)
                  if (userIsDeveloper) {
                    regexError.Append(" [");
                    regexError.Append(regex.ToString());
                    regexError.Append("]");
                  }

                  RegexCheckedColumnExampleInfo exampleInfo = meta.GetRegexCheckedColumnExample(keyInfo.PureKeyName);
                  if (exampleInfo != null) {
                    regexError.Append(". Example(s) of correct pattern: ");
                    regexError.Append(exampleInfo.Content);
                  }

                  errorDict.Add(keyInfo.Key, regexError.ToString());
                  //ModelState.AddModelError(keyInfo.Key, regexError.ToString());
                }
              }
          }
        }

        //lastly, check number limits if data type is number types
        //ColumnName1=min:23.555|max:75.112;ColumnName2=max:36.991
        NumberLimitColumnInfo numberLimitInfo = meta.GetNumberLimitColumn(keyInfo.PureKeyName);
        if (Aibe.DH.NumberDataTypes.Contains(keyInfo.DataType) && //if it is indeed number data types
          numberLimitInfo != null) { //And the limit keys contain pure key name
          double columnValue;
          bool result = double.TryParse(value.ToString(), out columnValue);
          if (result) {
            if (numberLimitInfo.Min > columnValue) //min is violated
              errorDict.Add(keyInfo.Key, string.Concat(
                "The input value [", columnValue, "] for field [",
                keyInfo.PureKeyName.ToCamelBrokenString(),
                "] is smaller than the minimum limit [", numberLimitInfo.Min, "]"
              ));
            //ModelState.AddModelError(keyInfo.Key, string.Concat(
            //    "The input value [", columnValue, "] for field [",
            //    keyInfo.PureKeyName.ToCamelBrokenString(),
            //    "] is smaller than the minimum limit [", numberLimitInfo.Min, "]"
            //  ));
            if (numberLimitInfo.Max < columnValue) { //max is violated
              errorDict.Add(keyInfo.Key, string.Concat(
                "The input value [", columnValue, "] for field [",
                keyInfo.PureKeyName.ToCamelBrokenString(),
                "] is greater than the maximum limit [", numberLimitInfo.Max, "]"
              ));
              //ModelState.AddModelError(keyInfo.Key, string.Concat(
              //  "The input value [", columnValue, "] for field [",
              //  keyInfo.PureKeyName.ToCamelBrokenString(),
              //  "] is greater than the maximum limit [", numberLimitInfo.Max, "]"
              //));
            }
          }
        }
      }
      return errorDict;
    }

    private static Type getTableType(string prefix, string tableName) {
      return Type.GetType(string.Concat(prefix, tableName)); //it is always in the Aiwe.Models.DB. TODO not sure if it is the best way
    }

    private static PropertyInfo getColumnPropertyInfo(string prefix, string tableName, string columnName) {
      Type tempClass = getTableType(prefix, tableName);
      object tableObject = Activator.CreateInstance(tempClass);
      return tempClass.GetProperty(columnName);
    }

    private static bool columnIsRequiredByAttribute(string prefix, string tableName, string columnName) {
      PropertyInfo propertyInfo = getColumnPropertyInfo(prefix, tableName, columnName);
      //CustomAttributeData cad = propertyInfo.GetCustomAttributesData()
      //  .FirstOrDefault(x => x.ToString().EndsWith("RequiredAttribute"));
      CustomAttributeData cad = propertyInfo.CustomAttributes
        .FirstOrDefault(x => x.AttributeType.ToString().EndsWith("RequiredAttribute"));
      return cad != null;
    }

    private static bool columnIsNullableByClass(string prefix, string tableName, string columnName) {
      PropertyInfo propertyInfo = getColumnPropertyInfo(prefix, tableName, columnName);
      string propertyType = propertyInfo.PropertyType.ToString();
      return Aibe.DH.NullableIndicators.Any(x => propertyType.StartsWith(Aibe.DH.SharedPrefixDataType + x));
    }

    private static int getStringLengthFor(string prefix, string tableName, string columnName) {
      PropertyInfo propertyInfo = getColumnPropertyInfo(prefix, tableName, columnName);
      //CustomAttributeData cad = propertyInfo.GetCustomAttributesData()
      //  .FirstOrDefault(x => x.ToString().EndsWith("StringLengthAttribute"));
      CustomAttributeData cad = propertyInfo.CustomAttributes
        .FirstOrDefault(x => x.AttributeType.ToString().EndsWith("StringLengthAttribute"));
      return (int)cad.ConstructorArguments[0].Value; //this should be Int32 type actually
    }
  }
}
