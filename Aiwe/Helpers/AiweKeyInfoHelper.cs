using System;
using System.Collections.Generic;
using Extension.Database.SqlServer;

namespace Aiwe.Helpers {
  public class AiweKeyInfoHelper {
    //TODO datetime data parsing could be problematic if not standardized
    public static object ExtractValueAsObjectForWebApi(string dataType, string dataValue, DateTime refDtNow,
      string tableName = null, string pureKeyName = null, bool isTimeStamp = false, bool isTimeStampFixed = false, 
      int timeStampShift = 0, bool isAutoGenerated = false, List<KeyValuePair<string, string>> tableColumnNamePairs = null) { //given string of data type and value, change it to the appropriate object!
      if (string.IsNullOrWhiteSpace(dataType) || string.IsNullOrWhiteSpace(dataValue) || dataValue.ToUpper().Trim() == "NULL") //null immediately returned
        return null;

      if (isTimeStamp) {
        DateTime timeStamp = refDtNow.AddSeconds(timeStampShift);
        if (string.IsNullOrWhiteSpace(dataValue) || !isTimeStampFixed) //if the value is empty or is not fixed
          return timeStamp; //immediately returns the object
        //if the value is not empty or it is fixed, then follow the procedure        
      }

      if (isAutoGenerated) { //gives next value for auto-generation number
        if (tableColumnNamePairs == null) { //single valued
          decimal decVal = SQLServerHandler.GetAggregatedValue(tableName, pureKeyName, "MAX", Aibe.DH.DataDBConnectionString);
          return decVal + 1;
        } else {
          tableColumnNamePairs.Insert(0, new KeyValuePair<string, string>(tableName, pureKeyName));
          decimal decVal = SQLServerHandler.GetAggregatedValues(tableColumnNamePairs, "MAX", Aibe.DH.DataDBConnectionString);
          return decVal + 1;
        }
      }

      try {
        bool parseResult;
        string valueRaw = dataValue;
        switch (dataType) {
          case Aibe.DH.StringDataType:
            if (!valueRaw.StartsWith("'") || !valueRaw.EndsWith("'") || valueRaw.Length < 3)
              return null;
            return valueRaw.Substring(1, valueRaw.Length - 2);
          case Aibe.DH.Int16DataType:
            short valInt16;
            parseResult = short.TryParse(valueRaw, out valInt16);
            if (parseResult)
              return valInt16;
            else return null;
          case Aibe.DH.Int32DataType:
            int valInt32;
            parseResult = int.TryParse(valueRaw, out valInt32);
            if (parseResult)
              return valInt32;
            else return null;
          case Aibe.DH.Int64DataType:
            long valInt64;
            parseResult = long.TryParse(valueRaw, out valInt64);
            if (parseResult)
              return valInt64;
            else return null;
          case Aibe.DH.DateTimeDataType:
            DateTime valDt; //this is going to be quite tricky
            if (!valueRaw.StartsWith("'") || !valueRaw.EndsWith("'") || valueRaw.Length < 3)
              return null;
            string dtStr = valueRaw.Substring(1, valueRaw.Length - 2);
            parseResult = DateTime.TryParse(dtStr, out valDt);
            if (parseResult)
              return valDt;
            else return null;
          case Aibe.DH.UInt16DataType:
            ushort valUInt16;
            parseResult = ushort.TryParse(valueRaw, out valUInt16);
            if (parseResult)
              return valUInt16;
            else return null;
          case Aibe.DH.UInt32DataType:
            uint valUInt32;
            parseResult = uint.TryParse(valueRaw, out valUInt32);
            if (parseResult)
              return valUInt32;
            else return null;
          case Aibe.DH.UInt64DataType:
            ulong valUInt64;
            parseResult = ulong.TryParse(valueRaw, out valUInt64);
            if (parseResult)
              return valUInt64;
            else return null;
          case Aibe.DH.ByteDataType:
            byte valByte;
            parseResult = byte.TryParse(valueRaw, out valByte);
            if (parseResult)
              return valByte;
            else return null;
          case Aibe.DH.SByteDataType:
            sbyte valSByte;
            parseResult = sbyte.TryParse(valueRaw, out valSByte);
            if (parseResult)
              return valSByte;
            else return null;
          case Aibe.DH.DecimalDataType:
            decimal valDec;
            parseResult = decimal.TryParse(valueRaw, out valDec);
            if (parseResult)
              return valDec;
            else return null;
          case Aibe.DH.DoubleDataType:
            double valDouble;
            parseResult = double.TryParse(valueRaw, out valDouble);
            if (parseResult)
              return valDouble;
            else return null;
          case Aibe.DH.SingleDataType:
            float valFloat;
            parseResult = float.TryParse(valueRaw, out valFloat);
            if (parseResult)
              return valFloat;
            else return null;
          case Aibe.DH.BooleanDataType:
            bool valBool;
            if (valueRaw.Trim() == "0")
              valBool = false;
            else if (valueRaw.Trim() == "1")
              valBool = true;
            else return null;
            return valBool;
          case Aibe.DH.CharDataType:
            char valChar;
            if (!valueRaw.StartsWith("'") || !valueRaw.EndsWith("'") || valueRaw.Length < 3)
              return null;
            valueRaw = valueRaw.Substring(1, valueRaw.Length - 2);
            parseResult = char.TryParse(valueRaw, out valChar);
            if (parseResult)
              return valChar;
            else return null;
          default:
            return null;
        }
      } catch {
        return null;
      }
    }
  }
}