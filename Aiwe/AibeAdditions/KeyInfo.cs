using System;
using System.Collections.Generic;
using System.Web.Mvc;
using Extension.Database.SqlServer;
using Extension.String;

namespace Aibe.Models.Core {
  public partial class KeyInfo {
    //TODO datetime data parsing could be problematic if not standardized
    public static object ExtractValueAsObjectForWebApi(string dataType, string dataValue, DateTime refDtNow,
      string tableName = null, string pureKeyName = null, bool isTimeStamp = false, bool isTimeStampFixed = false, 
      int timeStampShift = 0, bool isAutoGenerated = false, List<KeyValuePair<string, string>> tableColumnNamePairs = null) { //given string of data type and value, change it to the appropriate object!
      if (string.IsNullOrWhiteSpace(dataType) || string.IsNullOrWhiteSpace(dataValue) || dataValue.ToUpper().Trim() == "NULL") //null immediately returned
        return null;

      if (isTimeStamp) {
        DateTime timeStamp = refDtNow.AddSeconds(timeStampShift);
        if (string.IsNullOrWhiteSpace(dataValue) || !isTimeStampFixed) //if the value is empty or is not fixed
          return timeStamp; //immediately returns the object
        //if the value is not empty or it is fixed, then follow the procedure        
      }

      if (isAutoGenerated) { //gives next value for auto-generation number
        if (tableColumnNamePairs == null) { //single valued
          decimal decVal = SQLServerHandler.GetAggregatedValue(tableName, pureKeyName, "MAX", DH.DataDBConnectionString);
          return decVal + 1;
        } else {
          tableColumnNamePairs.Insert(0, new KeyValuePair<string, string>(tableName, pureKeyName));
          decimal decVal = SQLServerHandler.GetAggregatedValues(tableColumnNamePairs, "MAX", DH.DataDBConnectionString);
          return decVal + 1;
        }
      }

      try {
        bool parseResult;
        string valueRaw = dataValue;
        switch (dataType) {
          case DH.StringDataType:
            if (!valueRaw.StartsWith("'") || !valueRaw.EndsWith("'") || valueRaw.Length < 3)
              return null;
            return valueRaw.Substring(1, valueRaw.Length - 2);
          case DH.Int16DataType:
            short valInt16;
            parseResult = short.TryParse(valueRaw, out valInt16);
            if (parseResult)
              return valInt16;
            else return null;
          case DH.Int32DataType:
            int valInt32;
            parseResult = int.TryParse(valueRaw, out valInt32);
            if (parseResult)
              return valInt32;
            else return null;
          case DH.Int64DataType:
            long valInt64;
            parseResult = long.TryParse(valueRaw, out valInt64);
            if (parseResult)
              return valInt64;
            else return null;
          case DH.DateTimeDataType:
            DateTime valDt; //this is going to be quite tricky
            if (!valueRaw.StartsWith("'") || !valueRaw.EndsWith("'") || valueRaw.Length < 3)
              return null;
            string dtStr = valueRaw.Substring(1, valueRaw.Length - 2);
            parseResult = DateTime.TryParse(dtStr, out valDt);
            if (parseResult)
              return valDt;
            else return null;
          case DH.UInt16DataType:
            ushort valUInt16;
            parseResult = ushort.TryParse(valueRaw, out valUInt16);
            if (parseResult)
              return valUInt16;
            else return null;
          case DH.UInt32DataType:
            uint valUInt32;
            parseResult = uint.TryParse(valueRaw, out valUInt32);
            if (parseResult)
              return valUInt32;
            else return null;
          case DH.UInt64DataType:
            ulong valUInt64;
            parseResult = ulong.TryParse(valueRaw, out valUInt64);
            if (parseResult)
              return valUInt64;
            else return null;
          case DH.ByteDataType:
            byte valByte;
            parseResult = byte.TryParse(valueRaw, out valByte);
            if (parseResult)
              return valByte;
            else return null;
          case DH.SByteDataType:
            sbyte valSByte;
            parseResult = sbyte.TryParse(valueRaw, out valSByte);
            if (parseResult)
              return valSByte;
            else return null;
          case DH.DecimalDataType:
            decimal valDec;
            parseResult = decimal.TryParse(valueRaw, out valDec);
            if (parseResult)
              return valDec;
            else return null;
          case DH.DoubleDataType:
            double valDouble;
            parseResult = double.TryParse(valueRaw, out valDouble);
            if (parseResult)
              return valDouble;
            else return null;
          case DH.SingleDataType:
            float valFloat;
            parseResult = float.TryParse(valueRaw, out valFloat);
            if (parseResult)
              return valFloat;
            else return null;
          case DH.BooleanDataType:
            bool valBool;
            if (valueRaw.Trim() == "0")
              valBool = false;
            else if (valueRaw.Trim() == "1")
              valBool = true;
            else return null;
            return valBool;
          case DH.CharDataType:
            char valChar;
            if (!valueRaw.StartsWith("'") || !valueRaw.EndsWith("'") || valueRaw.Length < 3)
              return null;
            valueRaw = valueRaw.Substring(1, valueRaw.Length - 2);
            parseResult = char.TryParse(valueRaw, out valChar);
            if (parseResult)
              return valChar;
            else return null;
          default:
            return null;
        }
      } catch {
        return null;
      }
    }

    public object ExtractValueAsObject(FormCollection collections, DateTime refDtNow, bool filterStyle = false, 
      List<KeyValuePair<string, string>> tableColumnNamePairs = null) {
      bool parseResult;
      string value = collections[Key];

      if (filterStyle) {
        if (DataType.EqualsIgnoreCase(DH.StringDataType) || DataType.EqualsIgnoreCase(DH.CharDataType))
          return value;
        else if (DH.NumberDataTypes.Contains(DataType)) {
          decimal valDecimalFilter;
          parseResult = decimal.TryParse(value, out valDecimalFilter);
          if (parseResult)
            return valDecimalFilter;
          else return null;
        } else if (DataType.EqualsIgnoreCase(DH.DateTimeDataType)) {
          string dtStr = value;
          string timeStr = AddKeyName.EndsWith(DH.FromName) ? //get the time string
            collections[PureKeyName + DH.FilterTimeAppendixFrontName + DH.FromName] :
            collections[PureKeyName + DH.FilterTimeAppendixFrontName + DH.ToName];
          if (!string.IsNullOrWhiteSpace(timeStr)) //time string exists
            dtStr += " " + timeStr;
          DateTime valDt;
          parseResult = DateTime.TryParse(dtStr, out valDt);
          if (parseResult)
            return valDt;
          else return null;
        } else if (DataType.EqualsIgnoreCase(DH.BooleanDataType)) {
          //string parseVal = value?.ToString() == "on" ? "true" : "false";
          bool valBool;
          parseResult = bool.TryParse(value, out valBool);
          if (parseResult)
            return valBool;
          else return null;
        }
        return null; //imparsable
      }

      if (IsTimeStamp) {
        DateTime timeStamp = refDtNow.AddSeconds(TimeStampShift);
        if (string.IsNullOrWhiteSpace(value) || !IsTimeStampFixed) //if the value is empty or is not fixed
          return timeStamp; //immediately returns the object
        //if the value is not empty or it is fixed, then follow the procedure        
      }

      if (IsAutoGenerated) { //gives next value for auto-generation number
        if (tableColumnNamePairs == null) { //single valued
          decimal decVal = SQLServerHandler.GetAggregatedValue(TableName, PureKeyName, "MAX", DH.DataDBConnectionString);
          return decVal + 1;
        } else {
          tableColumnNamePairs.Insert(0, new KeyValuePair<string, string>(TableName, PureKeyName));
          decimal decVal = SQLServerHandler.GetAggregatedValues(tableColumnNamePairs, "MAX", DH.DataDBConnectionString);
          return decVal + 1;
        }
      }

      switch (DataType) {
        case DH.StringDataType:
          string picStr = collections[PureKeyName + DH.CreateEditPictureLinkAppendixName]; //Non filter time
          if (!string.IsNullOrWhiteSpace(picStr)) {
            //Do something if necessary!
          }
          return value;
        case DH.Int16DataType:
          short valInt16;
          parseResult = short.TryParse(value, out valInt16);
          if (parseResult)
            return valInt16;
          else return null;
        case DH.Int32DataType:
          int valInt32;
          parseResult = int.TryParse(value, out valInt32);
          if (parseResult)
            return valInt32;
          else return null;
        case DH.Int64DataType:
          long valInt64;
          parseResult = long.TryParse(value, out valInt64);
          if (parseResult)
            return valInt64;
          else return null;
        case DH.DateTimeDataType:
          DateTime valDt; //this is going to be quite tricky
          string dtStr = value;
          string timeStr = collections[PureKeyName + DH.CreateEditTimeAppendixName]; //Non filter time
          //string timeStr = filterStyle ? AddKeyName.EndsWith(ConstantHelper.FromName) ? //get the time string
          //  collections[PureKeyName + ConstantHelper.FilterTimeAppendixFrontName + ConstantHelper.FromName] :
          //  collections[PureKeyName + ConstantHelper.FilterTimeAppendixFrontName + ConstantHelper.ToName] :
          //  collections[PureKeyName + ConstantHelper.CreateEditTimeAppendixName]; //Non filter time
          if (!string.IsNullOrWhiteSpace(timeStr)) //time string exists
            dtStr += " " + timeStr;
          parseResult = DateTime.TryParse(dtStr, out valDt);
          if (parseResult)
            return valDt;
          else return null;
        case DH.UInt16DataType:
          ushort valUInt16;
          parseResult = ushort.TryParse(value, out valUInt16);
          if (parseResult)
            return valUInt16;
          else return null;
        case DH.UInt32DataType:
          uint valUInt32;
          parseResult = uint.TryParse(value, out valUInt32);
          if (parseResult)
            return valUInt32;
          else return null;
        case DH.UInt64DataType:
          ulong valUInt64;
          parseResult = ulong.TryParse(value, out valUInt64);
          if (parseResult)
            return valUInt64;
          else return null;
        case DH.ByteDataType:
          byte valByte;
          parseResult = byte.TryParse(value, out valByte);
          if (parseResult)
            return valByte;
          else return null;
        case DH.SByteDataType:
          sbyte valSByte;
          parseResult = sbyte.TryParse(value, out valSByte);
          if (parseResult)
            return valSByte;
          else return null;
        case DH.DecimalDataType:
          decimal valDec;
          parseResult = decimal.TryParse(value, out valDec);
          if (parseResult)
            return valDec;
          else return null;
        case DH.DoubleDataType:
          double valDouble;
          parseResult = double.TryParse(value, out valDouble);
          if (parseResult)
            return valDouble;
          else return null;
        case DH.SingleDataType:
          float valFloat;
          parseResult = float.TryParse(value, out valFloat);
          if (parseResult)
            return valFloat;
          else return null;
        case DH.BooleanDataType:
          //string parseVal = value?.ToString() == "on" ? "true" : "false";
          bool valBool;
          parseResult = bool.TryParse(value, out valBool);
          if (parseResult)
            return valBool;
          else return null;
        case DH.CharDataType:
          char valChar;
          parseResult = char.TryParse(value, out valChar);
          if (parseResult)
            return valChar;
          else return null;
        default:
          return null;
      }
    }
  }
}