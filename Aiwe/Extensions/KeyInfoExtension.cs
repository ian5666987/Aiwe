using System;
using System.Collections.Generic;
using System.Web.Mvc;
using Extension.Database.SqlServer;
using Extension.String;
using Aibe.Models.Core;

namespace Aiwe.Extensions {
  public static class KeyInfoExtension {
    public static object ExtractValueAsObject(this KeyInfo keyInfo, FormCollection collections, DateTime refDtNow, bool filterStyle = false, 
      List<KeyValuePair<string, string>> tableColumnNamePairs = null) {
      bool parseResult;
      string value = collections[keyInfo.Key];

      if (filterStyle) {
        if (keyInfo.DataType.EqualsIgnoreCase(Aibe.DH.StringDataType) || keyInfo.DataType.EqualsIgnoreCase(Aibe.DH.CharDataType))
          return value;
        else if (Aibe.DH.NumberDataTypes.Contains(keyInfo.DataType)) {
          decimal valDecimalFilter;
          parseResult = decimal.TryParse(value, out valDecimalFilter);
          if (parseResult)
            return valDecimalFilter;
          else return null;
        } else if (keyInfo.DataType.EqualsIgnoreCase(Aibe.DH.DateTimeDataType)) {
          string dtStr = value;
          string timeStr = keyInfo.AddKeyName.EndsWith(Aibe.DH.FromName) ? //get the time string
            collections[keyInfo.PureKeyName + Aibe.DH.FilterTimeAppendixFrontName + Aibe.DH.FromName] :
            collections[keyInfo.PureKeyName + Aibe.DH.FilterTimeAppendixFrontName + Aibe.DH.ToName];
          if (!string.IsNullOrWhiteSpace(timeStr)) //time string exists
            dtStr += " " + timeStr;
          DateTime valDt;
          parseResult = DateTime.TryParse(dtStr, out valDt);
          if (parseResult)
            return valDt;
          else return null;
        } else if (keyInfo.DataType.EqualsIgnoreCase(Aibe.DH.BooleanDataType)) {
          //string parseVal = value?.ToString() == "on" ? "true" : "false";
          bool valBool;
          parseResult = bool.TryParse(value, out valBool);
          if (parseResult)
            return valBool;
          else return null;
        }
        return null; //imparsable
      }

      if (keyInfo.IsTimeStamp) {
        DateTime timeStamp = refDtNow.AddSeconds(keyInfo.TimeStampShift);
        if (string.IsNullOrWhiteSpace(value) || !keyInfo.IsTimeStampFixed) //if the value is empty or is not fixed
          return timeStamp; //immediately returns the object
        //if the value is not empty or it is fixed, then follow the procedure        
      }

      if (keyInfo.IsAutoGenerated) { //gives next value for auto-generation number
        if (tableColumnNamePairs == null) { //single valued
          decimal decVal = SQLServerHandler.GetAggregatedValue(keyInfo.TableName, keyInfo.PureKeyName, "MAX", Aibe.DH.DataDBConnectionString);
          return decVal + 1;
        } else {
          tableColumnNamePairs.Insert(0, new KeyValuePair<string, string>(keyInfo.TableName, keyInfo.PureKeyName));
          decimal decVal = SQLServerHandler.GetAggregatedValues(tableColumnNamePairs, "MAX", Aibe.DH.DataDBConnectionString);
          return decVal + 1;
        }
      }

      switch (keyInfo.DataType) {
        case Aibe.DH.StringDataType:
          string picStr = collections[keyInfo.PureKeyName + Aibe.DH.CreateEditPictureLinkAppendixName]; //Non filter time
          if (!string.IsNullOrWhiteSpace(picStr)) {
            //Do something if necessary!
          }
          return value;
        case Aibe.DH.Int16DataType:
          short valInt16;
          parseResult = short.TryParse(value, out valInt16);
          if (parseResult)
            return valInt16;
          else return null;
        case Aibe.DH.Int32DataType:
          int valInt32;
          parseResult = int.TryParse(value, out valInt32);
          if (parseResult)
            return valInt32;
          else return null;
        case Aibe.DH.Int64DataType:
          long valInt64;
          parseResult = long.TryParse(value, out valInt64);
          if (parseResult)
            return valInt64;
          else return null;
        case Aibe.DH.DateTimeDataType:
          DateTime valDt; //this is going to be quite tricky
          string dtStr = value;
          string timeStr = collections[keyInfo.PureKeyName + Aibe.DH.CreateEditTimeAppendixName]; //Non filter time
          //string timeStr = filterStyle ? AddKeyName.EndsWith(ConstantHelper.FromName) ? //get the time string
          //  collections[PureKeyName + ConstantHelper.FilterTimeAppendixFrontName + ConstantHelper.FromName] :
          //  collections[PureKeyName + ConstantHelper.FilterTimeAppendixFrontName + ConstantHelper.ToName] :
          //  collections[PureKeyName + ConstantHelper.CreateEditTimeAppendixName]; //Non filter time
          if (!string.IsNullOrWhiteSpace(timeStr)) //time string exists
            dtStr += " " + timeStr;
          parseResult = DateTime.TryParse(dtStr, out valDt);
          if (parseResult)
            return valDt;
          else return null;
        case Aibe.DH.UInt16DataType:
          ushort valUInt16;
          parseResult = ushort.TryParse(value, out valUInt16);
          if (parseResult)
            return valUInt16;
          else return null;
        case Aibe.DH.UInt32DataType:
          uint valUInt32;
          parseResult = uint.TryParse(value, out valUInt32);
          if (parseResult)
            return valUInt32;
          else return null;
        case Aibe.DH.UInt64DataType:
          ulong valUInt64;
          parseResult = ulong.TryParse(value, out valUInt64);
          if (parseResult)
            return valUInt64;
          else return null;
        case Aibe.DH.ByteDataType:
          byte valByte;
          parseResult = byte.TryParse(value, out valByte);
          if (parseResult)
            return valByte;
          else return null;
        case Aibe.DH.SByteDataType:
          sbyte valSByte;
          parseResult = sbyte.TryParse(value, out valSByte);
          if (parseResult)
            return valSByte;
          else return null;
        case Aibe.DH.DecimalDataType:
          decimal valDec;
          parseResult = decimal.TryParse(value, out valDec);
          if (parseResult)
            return valDec;
          else return null;
        case Aibe.DH.DoubleDataType:
          double valDouble;
          parseResult = double.TryParse(value, out valDouble);
          if (parseResult)
            return valDouble;
          else return null;
        case Aibe.DH.SingleDataType:
          float valFloat;
          parseResult = float.TryParse(value, out valFloat);
          if (parseResult)
            return valFloat;
          else return null;
        case Aibe.DH.BooleanDataType:
          //string parseVal = value?.ToString() == "on" ? "true" : "false";
          bool valBool;
          parseResult = bool.TryParse(value, out valBool);
          if (parseResult)
            return valBool;
          else return null;
        case Aibe.DH.CharDataType:
          char valChar;
          parseResult = char.TryParse(value, out valChar);
          if (parseResult)
            return valChar;
          else return null;
        default:
          return null;
      }
    }
  }
}